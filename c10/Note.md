# 第10章 32位Intel微处理器编程架构
Intel32位微处理器编程架构简称IA-32(Intel Architecture, 32-bit)，是以1978年的8086处理器为基础发展起来的。
8086处理器拥有20根地址线，可以寻址 $2^{20}=1MB$内存。但是它的内部处理器是16位的，无法在程序中访问整个 $1MB$内存。所以，它是第一个支持内存分段模型的处理器。8086只有一种工作模式，叫做`实模式`。

32位处理器是从8086发展而来的，具有延续性和兼容性。一般来说，32位处理器具有32根地址线，数据线的数量一般是32位或64根。因此，它能够寻址 $2^{32}=4GB$的内存空间，能够同时读写4字节或者8字节,当然也可以按照一个字节或一个字访问内存。

## 10.1 IA-32架构的基本执行环境
### 10.1.1 寄存器的扩展
在16位处理器中，拥有8个通用寄存器，分别是AX, BX, CX, DX, SI, DI, SP, BP。其中，前四个处理器还能够拆分为两个独立的8位处理器来使用。分别记为AH,AL,BH,BL,CH,CL,DH,DL。32位处理器在16位处理器的基础上，扩展了这8个通用寄存器的长度(扩展为32位)。并在其名字前加上E(Extend)表示为扩展的寄存器。如EAX, EBX, ECX, EDX等。我们可以在程序中使用这些寄存器(即使是在实模式下)，如下所示：
```
mov eax, 0xf0000005
mov ecx, eax
add edx, ecx
```
值得注意的是，这里源操作数和目的操作数的长度必须相同，个别特殊用途的指令除外。
```
mov eax, cx    ; 错误的写法
```
为了保持兼容性，EAX,EBX,ECX,EDX的低16位仍然能够保持16位模式使用。

同样的，IP寄存器也同样的扩展为32位，叫做EIP。这样我们就能够在程序中寻址 $4GB$的内存空间。因此我们根本不需要分段。或者说将整个内存看作是一个大段，这种方式即为`平坦模型`。

标志寄存器FLAGS同样也扩展为32位，叫做EFLAGS，其低16位与原先保持一致，高16位将会在后面学习。

在16位模式下，一个程序可以自由地访问不属于它的内存空间，这显然是不安全的行为。但是没有方法阻止这种行为。在32位模式下，加载一个程序到内存中时，先定义该程序所拥有的段，然后才允许使用这些段。定义段时，除了定义段的基地址，还附加了`段界限、特权级别、类型`等属性。在16位模式下，CS, DS, ES, SS寄存器保存的是段地址，在32位模式下，这四个段寄存器保存的不在是段地址，而是段选择子。因此，这四个寄存器不应该叫做段寄存器了，而是叫做段选择器。除了16位的段选择器以外，还包含64位的不可见部分，叫做`描述符高速缓存器`，里面有关于段的各种属性。这部分内容由处理器使用。在32位模式下，还新增了两个额外的段选择器，分别是FS, GS。

以上提及的知识在后续将会逐一讲解。

### 10.1.2 基本的工作模式
8086是16位的处理器，只能够工作在实模式下。而80286虽然也是16位的处理器，但是却提出了保护模式的概念。这里主要学习80386，其能够工作在保护模式下。

### 10.1.3 线性地址
为IA-32处理器编程时，在访问内存时，需要给出段地址和偏移地址。传统上，段地址和偏移地址称为逻辑地址，偏移地址叫做有效地址(Effective Address, EA)，在指令中给出有效地址的方式叫做寻址方式(Addressing Mode)。

处理器内部的段部件用来管理段。段部见将段地址和偏移地址相加，得到访问内存的地址。一般来说， 段部见产生的地址就是物理地址。
IA-32处理器支持多任务。在多任务背景下，可能会造成内存的浪费。因此IA-32支持分页功能。当页功能开启时，段部件所产生的地址就不再是物理地址了，还需要经过页部件转换，才能够得到真正的物理地址。此时，段部件产生的地址叫做`线性地址`。

有关分页、分段的知识将会是整个学习的重点。

## 10.2 现代处理器的结构和特点
### 10.2.1 流水线
早在8086时代，处理器内部就有6字节的指令预取队列。当执行指令时，如果总线是空闲的，就可以提起预取指令并译码，能够大大加快指令的执行速度。

为了提高处理器的执行效率和速度，可以把一条指令拆分为若干个细小的步骤，并交给相应的单元去完成。各个单元的执行是独立的、并行的。如此一来，各个步骤的执行在时间上就会重叠起来，这种执行指令的方法就是流水线（Pipe-Line）技术。
### 10.2.2 高速缓存
高速缓存其实是基于程序的局部性原理的。利用程序运行时的局部性原理，可以把处理器正在访问和即将访问的指令和数据块从内存调入
高速缓存中。于是，每当处理器要访问内存时，首先检索高速缓存。如果要访问的内容已经在高速
缓存中，那么，很好，可以用极快的速度直接从高速缓存中取得，这称为命中（Hit）；否则，称为
不中（Miss）。在不中的情况下，处理器在取得需要的内容之前必须重新装载高速缓存，而不只是
直接到内存中去取那个内容。高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为
此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为不中惩罚（Miss 
Penalty）
### 10.2.3 乱序执行
### 10.2.4 寄存器重命名
考虑以下例子：
```
mov eax,[mem1]
shl eax,3
mov [mem2],eax
mov eax,[mem3]
add eax,2
mov [mem4],eax
```
虽然这里都使用了EAX寄存器，但是两个操作是完全没有关系的。处理器也是这样认为的，它会为EAX使用一个临时的寄存器，这样的话，加法和乘法就能够并发执行了。

寄存器重命名以一种完全自动和非常简单的方式工作。每当指令写逻辑寄存器时，处理器就为
那个逻辑寄存器分配一个新的临时寄存器。再来看一个例子：
```
mov eax,[mem1]
mov ebx,[mem2]
add ebx,eax
shl eax,3
mov [mem3],eax
mov [mem4],ebx
```
假定现在 mem1 的内容在高速缓存里，可以立即取得，但 mem2 的内容不在高速缓存中。这意
味着，左移操作可以在加法之前开始（使用临时寄存器代替 EAX）。为左移的结果使用一个新的临
时寄存器，其好处是 EAX 寄存器中仍然是以前的内容，它将一直保持这个值，直到 EBX 寄存器中
的内容就绪，然后同它一起做加法运算。如果没有寄存器重命名机制，左移操作将不得不等待从内
存中读取 mem2 的内容到 EBX 寄存器以及加法操作完成。
在所有的操作都完成之后，那个代表 EAX 寄存器最终结果的临时寄存器的内容被写入真实的
EAX 寄存器，该处理过程称为引退（Retirement）。
所有通用寄存器，堆栈指针、标志、浮点寄存器，甚至段寄存器都有可能被重命名。
### 10.2.5 分支目标预测
P191.

## 10.3 32位模式的指令系统

